/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2025 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include "stm32h5xx.h"
#include <inttypes.h>
#include "stm32h5xx_hal.h"
#include "common.h"
#include "fft.h"
#include "memory.h"
#include <stdbool.h>
#include "dma_linkedlist.h"
#include "cbor_format.h"
#include "wisun_frame.h"
#include "wisun_transport.h"
#include "storage_mid.h"
#include <math.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
typedef struct __attribute__((packed)) {
    float freq;      // Hz
    float amplitude;    // FFT 진폭
} FftData_t;

typedef struct { uint16_t volt_raw; uint16_t curr_raw; uint32_t t_us; } VIRead;

FftData_t fft_packet[FFT_SIZE / 2];
arm_rfft_fast_instance_f32 fftInstance;

typedef enum {
    WAITING_FOR_STX,
    RECEIVING_PACKET
} PacketParserState;

typedef struct {
    bool     pending;
    uint8_t  which_idx;   // 링버퍼 인덱스 (여기선 1개만 쓰므로 0)
    uint16_t nonce;
    uint32_t due_tick;    // 전송 예정 시각 (ms)
} tx_task_t;

typedef struct {
    bool     light_on;
    float    voltage;
    float    current;
    float    supersonic;
    uint32_t count;
} snapshot_t;

typedef struct {
    bool     pending;
    uint32_t due_tick;
    uint16_t nonce;
    char     topic[16];
    uint8_t  ok;

    uint8_t  p_on_valid, p_on;   // light_on 결과 회신용
} resp_task_t;

typedef struct {
    uint32_t start_after_ms;  // p.start_after_ms
    uint32_t slot_len_ms;     // p.slot_len_ms
    uint32_t jitter_ms;       // p.jitter_ms
    uint16_t max_mid;         // p.max_mid
    enum { ORDER_MID_DESC=0 } order;
} resp_slot_cfg_t;

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define RX_BUFFER_SIZE 100
#define PACKET_MAX_SIZE 256
#define UID_ADDRESS  ((uint32_t*) 0x08FFF800)
#define __DCACHE_PRESENT 1U
#define __ICACHE_PRESENT 1U
//#define VREFINT_CAL_ADDR  ((uint16_t*) (0x08FFF810))
//#define VREFINT_CAL_VALUE  (*VREFINT_CAL_ADDR)
#define SAMPLING_RATE 950000.0f
#define PACKET_STX    0x02
#define PACKET_ETX    0x03
#define SIG1          0xAA
#define SIG2          0xAB

#define CMD_LIGHT_ON 0x10
#define CMD_LIGHT_OFF 0x11
#define CMD_GET_FFT 0x20
#define CMD_GET_VOLD 0x21
#define CMD_GET_STATUS 0x30
//#define FFT_TOTAL_SAMPLES  (CYCLE_SAMPS * N_CYCLES)


#define FFT_DURATION_MS 60000  // 측정 시간 1분 (1000 * 60)
#define FFT_DELAY_MS     100

#define TRIGGER_THRESHOLD  0.1f
#define TRIGGER_TIMEOUT 1000
#define FFT_WINDOW_MS 200
#define NUM_CHANNELS 3
#define ADC_BUFFER_SIZE 256
#define ULTRA_BUF_LEN   4096

#define ADC_MAX_COUNTS    4095.0f
#define VREF_FIXED        3.3f

// 전압 분배비 (없으면 1.0으로)
#define R_TOP_V           100000.0f   // 예: 100k
#define R_BOT_V           10000.0f    // 예: 10k
#define V_DIV_GAIN        ((R_TOP_V + R_BOT_V) / R_BOT_V)   // 분배 없으면 R_TOP_V=0, R_BOT_V=1

// 전류측정 체인
#define R_SHUNT           0.05f       // 셔ント(Ω)
#define I_AMP_GAIN        50.0f       // 증폭배수(x)
// ***중요*** 0A일 때 화면에 찍힌 curr_raw 숫자를 여기에 넣으세요!
#define I_OFFSET_RAW      1990
#define SNAP_RING_SIZE  1
#define SLOT_COUNT      8u
#define SLOT_LEN_MS     200u
#define SLOT_JITTER_MS  150u

#define LIGHT_Pin        GPIO_PIN_12       // 원하는 핀 번호
#define LIGHT_GPIO_Port  GPIOA
#ifndef MID_INVALID
#define MID_INVALID ((uint16_t)0xFFFF)
#endif

#ifndef SNAP_FFT_PAIRS
#define SNAP_FFT_PAIRS 16  // 기본 안전값
#endif

#ifndef SUP_MIN_HZ
#define SUP_MIN_HZ 20000.0f   // 20 kHz
#endif
#ifndef SUP_MAX_HZ
#define SUP_MAX_HZ 80000.0f   // 80 kHz
#endif

/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
ADC_HandleTypeDef hadc1;

RTC_HandleTypeDef hrtc;

TIM_HandleTypeDef htim2;

UART_HandleTypeDef huart1;
UART_HandleTypeDef huart2;
UART_HandleTypeDef huart6;

/* USER CODE BEGIN PV */
extern ADC_HandleTypeDef hadc2;
PacketParserState packet_state = WAITING_FOR_STX;
static snapshot_t g_snap[SNAP_RING_SIZE];
static uint8_t    g_snap_head = 0;
static bool       g_snap_inited = false;
static uint8_t  g_snap_enable      = 0;       // 0: off, 1: on
static uint32_t g_snap_interval_ms = 60000;   // 기본 60초
static uint32_t g_snap_next_tick   = 0;

static char     g_uid_str[40];
static uint32_t uid_ram_local[3]; // UID 복사본(스냅샷 payload 구성용)
static volatile bool     wisun_packet_ready = false;
static volatile uint16_t wisun_packet_len   = 0;
static uint8_t           wisun_packet_shadow[PACKET_MAX_SIZE];

static const float K_ADC2V   = VREF_FIXED / ADC_MAX_COUNTS;                 // raw → V
//static const float K_VIN     = K_ADC2V * V_DIV_GAIN;                        // raw → Vin(V)
//static const float K_CURR    = K_ADC2V / (R_SHUNT * I_AMP_GAIN);
//static volatile uint16_t adc_buffer[FFT_TOTAL_SAMPLES];
static volatile int      sample_index = 0;
static volatile resp_task_t g_resp = {0};
volatile uint8_t adc_done = 0;
volatile uint32_t g_monitor_count = 0;
static volatile int       wr_idx           = 0;
static volatile size_t   ultra_idx = 0;
static volatile bool     ultra_frame_ready = false;
static volatile bool     ultra_sampling_paused = false;
static volatile uint32_t t_frame_start_us = 0;
static uint8_t pa12_state = 0;
static volatile uint32_t t_frame_end_us   = 0;
volatile uint8_t receive_flag = 0;
volatile uint32_t tick_start = 0, tick_end = 0;
volatile uint32_t uid_ram[3];
volatile uint16_t g_last_rx_tmid = 0;

bool fft_data_sent = false;

uint8_t last_received_packet[RX_BUFFER_SIZE];
uint16_t last_received_len = 0;
uint8_t rxBuffer[100];
uint8_t ADCFlag = 0;
uint8_t rxByte, rxByte1;
uint8_t wisun_rx;
uint8_t pcBuffer[RX_BUFFER_SIZE];
uint8_t pc_rx_buffer[RX_BUFFER_SIZE];
uint8_t wisun_rx_buffer[RX_BUFFER_SIZE];
uint8_t tx_forward_buffer[RX_BUFFER_SIZE];
uint8_t pc_rx_index = 0;
uint8_t wisun_rx_index = 0;
uint8_t packet_buffer[256];
uint8_t packet_index = 0;
uint8_t wisun_packet_index = 0;
uint8_t packet_mode = 0;
uint8_t send_count = 0;

uint32_t prev_tick = 0;
uint32_t final_response[100];

uint16_t vrefint_adc;
uint16_t adc_dma_buffer[FFT_SIZE];
uint16_t my_module_id = 0x0000;
uint16_t my_mid = MID_INVALID;
uint16_t target_mid = 0;
uint16_t adc_raw_volt = 0;
uint16_t adc_raw_curr = 0;
uint16_t adc_raw_temp = 0;
uint16_t raw_buffer[FFT_SIZE];
uint16_t loaded;

float32_t inputSignal[FFT_SIZE];
float32_t outputSignal[FFT_SIZE];
float32_t magnitude[FFT_SIZE / 2];
float32_t totalMagnitude = 0;
float32_t energy = 0;
float32_t I_OFFSET_VOLT = 0.0f;
uint32_t last_tick = 0;

char debug_msg[64];
char uid_str[50];
char wisun_mid[10] = {0};  // MID ???   버퍼
char wisun_mac[20] = {0};

volatile uint8_t sendIDFlag = 0;
volatile uint8_t request_step = 0;
volatile uint16_t adc_index = 0;
volatile uint8_t fft_ready;
volatile uint8_t packet_flag = 0;
volatile uint32_t g_sec_tick = 0;
volatile uint8_t started = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART1_UART_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_ADC1_Init(void);
static void MX_USART6_UART_Init(void);
static void MX_TIM2_Init(void);
static void MX_RTC_Init(void);
/* USER CODE BEGIN PFP */
void Send_UID_UART2(void);
void Format_UID(char *msg, size_t size);
void Read_UID(void);
uint32_t Get_Device_ID(void);
void Send_Device_ID_UART2(void);
void Send_Broadcast_Command(uint8_t *request_data, uint8_t request_length);
uint32_t Read_ADC_Channel(uint32_t channel);
float Convert_ADC_To_Current(uint32_t adc_value);
float Convert_Voltage_To_Current(float voltage, float offset);
float Convert_Voltage_ADC(uint32_t adc_value);
uint32_t Read_Voltage_ADC(void);
float Get_Calibrated_Vref(void);
float Get_Offset_Voltage(void);
void Print_Voltage_Current(void);
//void Broadcast_Sensor_Data(void);
void readADCData(void);
void SendFFT_Packet(uint16_t target_mid, FftData_t *fft_data, uint8_t count);
void SendDataPacket(uint16_t target_mid, uint8_t *data, uint16_t data_length);
void ExtractFullFFT(FftData_t *dest);
void startADCInterrupt(void);
/*void Transfer_ADC_To_DAC(void);*/
void Query_MID_From_WiSUN();
void Parse_AT_Response(const char* buffer);
void PrintReceivedPacket(const char* prefix, const uint8_t* data, uint16_t length);
//void SendReceivedBroadcastPacket(void);
//void Process_WiSun_Command(wisun_rx_buffer, wisun_rx_index);
/*typedef void (*CmdHandler)(uint8_t *data, uint8_t len);
void Handle_LightOn(uint8_t *data, uint8_t len);
void Handle_LightOff(uint8_t *data, uint8_t len);
void Handle_GetFFT(uint8_t *data, uint8_t len);
void Handle_GetVoltage(uint8_t *data, uint8_t len);
void Handle_GetStatus(uint8_t *data, uint8_t len);*/
void StreetLight_ToggleTask(void);
//void loop_fft_for_duration(uint32_t duration_ms);
void ADC1_Start_Regular_IN18_IT(void);
void Ultra_ResumeNextFrame(void);
void Ultra_StartSampling(void);
void Print_FFT_Summary(uint16_t *raw_buf);
static inline float adc_to_vsense(uint16_t raw);
static inline float vsense_to_vin(float v_sense);
static inline float vsense_to_current(float v_sense, float offset_v);
static inline void PA12_toggle_soft(void);
void send_one_measurement(void);
static void init_uid_string(void);
static void Read_UID_local(void);
static inline uint16_t xorshift16(uint16_t x);
static void schedule_ordered_response(uint16_t nonce,
                                      const char* topic,
                                      uint8_t ok,
                                      const resp_slot_cfg_t* cfg);
static bool find_cbor_map_slice(const uint8_t* data, size_t data_len,
                                const uint8_t** cbor, size_t* cbor_len);
static void send_resp_now_from_task(void);
void tx_task_poll(void);
static void build_snapshot_packet(cbor_packet_t* rp, const snapshot_t* s,
                                  bool as_resp, const char* topic, uint16_t nonce);
static bool send_wisun_resp(uint16_t tmid, const uint8_t *cbor, size_t cbor_len);
static void mid_pack_uid12(uint8_t out12[12]);
void Send_Monitoring_Snapshot_JSON(void);
//static void Poll_Temperature_And_Print(void);
//void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

int __io_putchar(int ch)
{
    HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, HAL_MAX_DELAY);
    return ch;
}

static inline float adc_to_vsense(uint16_t raw) {
    return ((float)raw * VREF_FIXED) / ADC_MAX_COUNTS;
}

static inline float vsense_to_vin(float v_sense) {
    return v_sense * V_DIV_GAIN;
}

static inline float vsense_to_current(float v_sense, float offset_v) {
    // v_sense = offset_v + I * R_SHUNT * I_AMP_GAIN
    return (v_sense - offset_v) / (R_SHUNT * I_AMP_GAIN);
}
static inline void PA12_toggle_soft(void){
    pa12_state ^= 1;
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12,
        pa12_state ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

static inline void InvalidateDCacheByAddr(uint32_t *addr, int32_t dsize) {
    if (SCB->CCR & SCB_CCR_DC_Msk) {
        int32_t linesize = 32;  // 보통 Cortex-M33은 32-byte cache line
        uint32_t start = (uint32_t)addr & ~(linesize - 1);
        uint32_t end = ((uint32_t)addr + dsize + linesize - 1) & ~(linesize - 1);
        for (uint32_t p = start; p < end; p += linesize) {
            __DSB();
            SCB->DCIMVAC = p;
        }
        __DSB();
        __ISB();
    }
}

static inline uint16_t xorshift16(uint16_t x){
    if (x==0) x=0xACE1u;
    x ^= x << 7; x ^= x >> 9; x ^= x << 8;
    return x;
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) {
	if (huart->Instance == USART6)
	    {
	        if (pc_rx_index < RX_BUFFER_SIZE - 1)
	        {
	            pc_rx_buffer[pc_rx_index++] = rxByte;

	            // \n 수신되면 처리
	            if (rxByte == '\n')
	            {
	                // \r\n 제거
	                if (pc_rx_index >= 2 && pc_rx_buffer[pc_rx_index - 2] == '\r') {
	                    pc_rx_index -= 2;
	                } else {
	                    pc_rx_index -= 1;
	                }
	                pc_rx_buffer[pc_rx_index] = '\0';  // 문자열 종료

	                // UART1로 전송 (\r\n 붙여서)
	                HAL_UART_Transmit(&huart1, (uint8_t *)pc_rx_buffer, pc_rx_index, HAL_MAX_DELAY);
	                uint8_t crlf[] = "\r\n";
	                HAL_UART_Transmit(&huart1, crlf, 2, HAL_MAX_DELAY);

	                // PC에도 다시 echo 출력
	                HAL_UART_Transmit(&huart6, (uint8_t *)pc_rx_buffer, pc_rx_index, HAL_MAX_DELAY);
	                HAL_UART_Transmit(&huart6, crlf, 2, HAL_MAX_DELAY);

	                // 버퍼 초기화
	                memset(pc_rx_buffer, 0, RX_BUFFER_SIZE);
	                pc_rx_index = 0;
	            }
	        }
	        else
	        {
	            // 오버플로우 시 초기화
	            pc_rx_index = 0;
	            memset(pc_rx_buffer, 0, RX_BUFFER_SIZE);
	        }

	        // 다음 바이트 수신 준비
	        HAL_UART_Receive_IT(&huart6, &rxByte, 1);
	    }

	else if (huart->Instance == USART1) {

		    if (packet_state == WAITING_FOR_STX) {
		        // 바이너리 패킷의 시작 여부 검사
		        if (rxByte1 == PACKET_STX) {
		            wisun_rx_index = 0;
		            wisun_rx_buffer[wisun_rx_index++] = rxByte1;

		           //HAL_UART_Transmit(&huart6, &rxByte1, 1, HAL_MAX_DELAY);
		            packet_state = RECEIVING_PACKET;
		        }
		        // 그 외는 ASCII 응답으로 취급
		        else {
		            static char ascii_buffer[RX_BUFFER_SIZE];
		            static uint16_t ascii_index = 0;

		            if (ascii_index < RX_BUFFER_SIZE - 1) {
		                ascii_buffer[ascii_index++] = rxByte1;

		                if (rxByte1 == '\r' || rxByte1 == '\n') {
		                    // 마지막에 \r 또는 \n만 남기지 않도록 제거
		                    while (ascii_index >= 1 &&
		                          (ascii_buffer[ascii_index - 1] == '\r' || ascii_buffer[ascii_index - 1] == '\n')) {
		                        ascii_index--;
		                    }

		                    ascii_buffer[ascii_index] = '\0';  // 문자열 종료

		                    Parse_AT_Response(ascii_buffer);

		                    // "AT" 위치부터 출력
		                    char* at_ptr = strstr(ascii_buffer, "AT");
		                    if (at_ptr != NULL) {
		                        HAL_UART_Transmit(&huart6, (uint8_t*)at_ptr, strlen(at_ptr), HAL_MAX_DELAY);
		                    } else {
		                        HAL_UART_Transmit(&huart6, (uint8_t*)ascii_buffer, ascii_index, HAL_MAX_DELAY);
		                        HAL_UART_Transmit(&huart6, (uint8_t*)"\r\n", 2, HAL_MAX_DELAY);
		                    }

		                    ascii_index = 0;
		                    memset(ascii_buffer, 0, sizeof(ascii_buffer));
		                }
		            } else {
		                // 오버플로우 시 초기화
		                ascii_index = 0;
		                memset(ascii_buffer, 0, sizeof(ascii_buffer));
		            }
		        }
		    }

		    else if (packet_state == RECEIVING_PACKET) {
		        if (wisun_rx_index < RX_BUFFER_SIZE - 1) {
		            wisun_rx_buffer[wisun_rx_index++] = rxByte1;

		            if (rxByte1 == PACKET_ETX && wisun_rx_index >= 7) {
		                // 수신 완료
		                uint16_t packet_len = wisun_rx_index;

		                // 버퍼 복사 (→ 전송용)
		                memcpy(tx_forward_buffer, wisun_rx_buffer, packet_len);

		                // 수신 로그 출력
		                PrintReceivedPacket("Receive Packet : ", tx_forward_buffer, packet_len);

		                // MID 추출 및 중계 여부 판단
		                uint16_t target_mid = (uint16_t)tx_forward_buffer[4] | ((uint16_t)tx_forward_buffer[5] << 8);
		                if (target_mid != my_mid && target_mid != 0x0000) {
		                    HAL_UART_Transmit(&huart1, tx_forward_buffer, packet_len, HAL_MAX_DELAY);
		                }

		                // (PACKET_MAX_SIZE는 RX_BUFFER_SIZE 이상으로 정의되어 있어야 안전)
		                if (packet_len <= PACKET_MAX_SIZE) {
		                    memcpy((void*)wisun_packet_shadow, wisun_rx_buffer, packet_len);
		                    wisun_packet_len   = packet_len;
		                    wisun_packet_ready = true;
		                }

		                // 수신 상태 초기화
		                memset(wisun_rx_buffer, 0, sizeof(wisun_rx_buffer));
		                wisun_rx_index = 0;
		                packet_state = WAITING_FOR_STX;

		                // 최종 노드일 경우 → 응답도 가능 (여기선 하지 않아도 OK)
		            }
		        } else {
		            // 오버플로우 시 초기화
		            wisun_rx_index = 0;
		            packet_state = WAITING_FOR_STX;
		            memset(wisun_rx_buffer, 0, sizeof(wisun_rx_buffer));
		        }
		    }

		    // 마지막에 항상 재-arm
		    HAL_UART_Receive_IT(&huart1, &rxByte1, 1);
	}
}


// DATA 안에서 CBOR map 시작(A0..BF)을 찾아 슬라이스 반환
static bool find_cbor_map_slice(const uint8_t* data, size_t data_len,
                                const uint8_t** cbor, size_t* cbor_len)
{
    if (!data || !cbor || !cbor_len) return false;
    for (size_t i = 0; i < data_len; ++i) {
        if ((data[i] & 0xE0) == 0xA0) { // major type 5 = map
            *cbor     = &data[i];
            *cbor_len = data_len - i;
            return true;
        }
    }
    return false;
}


void ADC1_Start_Regular_IN18_IT(void)
{
    // CubeMX에서: Scan Disable, NbrOfConversion=1, Rank1=IN18,
    // Continuous Conversion Enable, EOC Selection=EOC 로 설정
    HAL_ADC_Start_IT(&hadc1);   // 한 번만 호출
}


void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
{
    if (hadc->Instance != ADC1) return;

    // 샘플 1개 저장
    uint16_t raw = HAL_ADC_GetValue(hadc);
    raw_buffer[wr_idx]  = raw;
    inputSignal[wr_idx] = ((float)raw * 3.3f / 4095.0f) - 1.65f;

    // 인덱스/프레임 완료 체크
    wr_idx++;
    if (wr_idx >= FFT_SIZE) {
        wr_idx = 0;
        ultra_frame_ready = true;

        // 다음 프레임 받기 전에 잠깐 멈춤
        ultra_sampling_paused = true;
        HAL_ADC_Stop_IT(&hadc1);   // ★ 프레임 처리/VI 읽는 동안 샘플링 일시정지
    }
}

/*
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM3) {
    	HAL_UART_Transmit(&huart6, (uint8_t*)"Tick\r\n", 6, HAL_MAX_DELAY);
        if (++g_sec_tick >= 10) {   // 1800초 = 30분
            HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_12);
            g_sec_tick = 0;
        }
    }
}
*/

static void mid_pack_uid12(uint8_t out12[12]) {
    memcpy(out12, (const void*)uid_ram, 12);
}

static bool send_wisun_resp(uint16_t tmid, const uint8_t *cbor, size_t cbor_len)
{
    wisun_frame_cfg_t cfg = {
        .sig1 = 0xAA,     // 응답/요청 공통 SIG1
        .sig2 = 0xAB,     // 응답 채널(또는 프로젝트 규칙에 맞게 조정)
        .tmid = tmid      // 요청의 TMID를 그대로 반사하는 게 일반적
    };
    // DATA 길이 255 바이트 제한 내에서 호출해야 합니다.
    return wisun_send_frame(&cfg, cbor, cbor_len, wisun_tx_adapter, NULL);
}

static void schedule_ordered_response(uint16_t nonce,
                                      const char* topic,
                                      uint8_t ok,
                                      const resp_slot_cfg_t* cfg)
{
    if (!cfg || !cfg->slot_len_ms) return;
    uint32_t now = HAL_GetTick();
    uint32_t base = cfg->start_after_ms;

    uint16_t M = (cfg->max_mid ? cfg->max_mid : 1);
    uint32_t idx = 0;
    if (cfg->order == ORDER_MID_DESC) {
        if (my_mid > 0 && my_mid <= M) idx = (uint32_t)(M - my_mid);
        else                           idx = 0;
    }

    uint16_t seed = (uint16_t)(uid_ram[0] ^ uid_ram[1] ^ uid_ram[2] ^ nonce);
    uint32_t jitter = cfg->jitter_ms ? (xorshift16(seed) % cfg->jitter_ms) : 0;

    __disable_irq();
    g_resp.pending  = true;
    g_resp.nonce    = nonce;
    g_resp.ok       = ok;
    memset((void*)g_resp.topic, 0, sizeof(g_resp.topic));
    strncpy((char*)g_resp.topic, topic, sizeof(g_resp.topic)-1);
    g_resp.due_tick = now + base + idx * cfg->slot_len_ms + jitter;
    __enable_irq();
}

static void send_resp_now_from_task(void)
{
    uint8_t uid12[12]; mid_pack_uid12(uid12);

    cbor_packet_t rp={0};
    rp.has_k=true; rp.k=1;
    rp.has_topic=true; strncpy(rp.topic,(const char*)g_resp.topic,sizeof(rp.topic)-1);
    rp.has_uid=true; memcpy(rp.uid, uid12, 12);
    rp.has_mid=true; rp.mid=my_mid;
    if (g_resp.nonce){ rp.has_n=true; rp.n=g_resp.nonce; }
    rp.has_ok=true; rp.ok=g_resp.ok;

    if (g_resp.p_on_valid) { rp.p_has_on = true; rp.p_on = g_resp.p_on; }

    uint8_t ob[256]; size_t on=0;
    if (cbor_encode_packet(ob,sizeof(ob),&rp,&on)) {
        wisun_frame_cfg_t cfg = { .sig1=0xAA,.sig2=0xAA,.tmid=0x0000 };
        (void)wisun_send_frame(&cfg, ob, on, wisun_tx_adapter, NULL);
    }
}

void tx_task_poll(void)
{
    if (!g_resp.pending) return;
    if ((int32_t)(HAL_GetTick() - g_resp.due_tick) < 0) return;

    __disable_irq();
    g_resp.pending = false;
    __enable_irq();

    send_resp_now_from_task();
}

void Print_FFT_Summary(uint16_t *raw_buf)
{
    char msg[96];
    const int step = 16; // ✅ 출력 줄 수 줄이기(테스트 후 조절)

    for (int i = 1; i < FFT_SIZE/2; i += step) {
    	int len = snprintf(msg, sizeof(msg),
    	                           "%.1f, %.5f, %.u\r\n",
    	                           fft_packet[i].freq,
    	                           fft_packet[i].amplitude,
    	                           raw_buf[i]);
		HAL_UART_Transmit(&huart6, (uint8_t*)msg, len, 10);
    }
}


/* void Process_Ultra_Frame_Then_VI(void)
{
    if (!ultra_frame_ready || !ultra_sampling_paused) return;
    static uint16_t local_raw[FFT_SIZE];
    static float    local_in [FFT_SIZE];
    __disable_irq();
    ultra_frame_ready = false;
    for (int i=0; i<FFT_SIZE; ++i) { local_raw[i] = raw_buffer[i]; local_in[i] = inputSignal[i]; }
    __enable_irq();

    VIRead vi;
    if (AD_DC_Injected_Once(&vi) == HAL_OK) {
        // --- 변환: 가장 단순 버전 ---
        float vin_v     = (float)vi.volt_raw * (3.3f / 4095.0f);
        float i_adc = (float)vi.curr_raw * K_ADC2V;

        // 간단 출력 (짧은 포맷)
        char m[96];
        int n = snprintf(m, sizeof(m),
                         "VI: %u,%u => %.3f V, %.3f A @ %luus\r\n",
                         vi.volt_raw, vi.curr_raw, vin_v, i_adc, vi.t_us);
        HAL_UART_Transmit(&huart6, (uint8_t*)m, n, 20);
    } else {
        char m[] = "VI read failed\r\n";
        HAL_UART_Transmit(&huart6, (uint8_t*)m, sizeof(m)-1, 10);
    }

    ExtractFullFFT(fft_packet);
    Print_FFT_Summary(local_raw);
    Ultra_ResumeNextFrame();
} */

void send_one_measurement(void) {
    uint8_t  cbor[128];
    size_t   n = 0;

    // 1) CBOR 인코딩
    if (!cbor_encode_measurement(cbor, sizeof(cbor),
                                 /*sensor_id*/18, /*t_us*/12345678u,
                                 /*value*/3.14f, /*ok*/true, &n)) {
        // 에러 처리
        return;
    }

    // 2) Wi-SUN 프레임 구성
    wisun_frame_cfg_t cfg = { .sig1 = 0xAA, .sig2 = 0xAB, .tmid = 0x0000 /*브로드캐스트*/ };

    // 3) 전송
    (void)wisun_send_frame(&cfg, cbor, n,
                           /*tx*/ (wisun_tx_fn)wisun_transport_send_blocking,
                           /*user*/ NULL);
}

static float compute_supersonic_rms_from_fftdata(const FftData_t* arr, uint16_t n)
{
    if (!arr || n == 0) return 0.0f;

    float sumsq = 0.0f;
    uint16_t cnt = 0;

    for (uint16_t i = 0; i < n; ++i) {
        float f = arr[i].freq;
        if (f >= SUP_MIN_HZ && f <= SUP_MAX_HZ) {
            float a = arr[i].amplitude; // 이미 magnitude라고 가정
            sumsq += a * a;
            cnt++;
        }
    }
    if (cnt == 0) return 0.0f;
    return sqrtf(sumsq / (float)cnt);  // RMS
}

static void build_snapshot_packet(cbor_packet_t* rp, const snapshot_t* s,
                                  bool as_resp, const char* topic, uint16_t nonce)
{
	uint8_t uid12[12]; mid_pack_uid12(uid12);
    memset(rp, 0, sizeof(*rp));
    rp->has_k     = true; rp->k = as_resp ? 1 : 2;        // 1=resp, 2=evt
    rp->has_topic = true; strncpy(rp->topic, topic, sizeof(rp->topic)-1);
    rp->has_uid = true; memcpy(rp->uid, uid12, 12);
    rp->has_mid   = true; rp->mid = my_mid;

    if (as_resp) { rp->has_ok = true; rp->ok = 1; }
    if (nonce)   { rp->has_n  = true; rp->n  = nonce; }

    // 측정치: 레거시(top-level)로 넣기 → 디코더 하위호환 유지
    rp->has_volt = true; rp->volt = s->voltage;
    rp->has_curr = true; rp->curr = s->current;
    // 초음파/진동 같은 부가값
    // 필요 시 cbor_format에 p_has_supersonic, p_supersonic 같은 키를 추가해 사용
    // 아래는 예시로 이름만 잡아둠(키 추가했으면 활성화)
    // rp->p_has_supersonic = true; rp->p_supersonic = s->supersonic;
    // rp->p_has_rmsx = true; rp->p_rmsx = s->rms_x;  ... 등

    // 스위치 상태
    rp->p_has_on = true; rp->p_on = s->light_on ? 1 : 0;

    // 카운터/타임스탬프 필요하면 추가
    // rp->has_time = true; rp->time_us = s->tick_ms;  // (legacy 't' 사용 시 주의: topic과 충돌 안 나게)
}

// ===== 필요한 외부 심볼들(프로젝트에 이미 있을 것으로 가정) =====

// ===== 구현 =====
void Send_Monitoring_Snapshot_JSON(void)
{
    if (!ultra_frame_ready || !ultra_sampling_paused) return;

    static uint16_t local_raw[FFT_SIZE];
    static float    local_in [FFT_SIZE];

    __disable_irq();
    ultra_frame_ready = false;
    for (int i=0; i<FFT_SIZE; ++i) {
        local_raw[i] = raw_buffer[i];
        local_in[i]  = inputSignal[i];
    }
    __enable_irq();

    // VI 측정
    VIRead vi; float vin_v = 0.0f, i_adc_v = 0.0f;
    if (AD_DC_Injected_Once(&vi) == HAL_OK) {
        vin_v  = (float)vi.volt_raw * (3.3f / 4095.0f);
        i_adc_v= (float)vi.curr_raw * K_ADC2V;
    }

    uint16_t temp_raw = 0;
    float temp_v = 0.0f;
    if (HAL_ADC_Start(&hadc2) == HAL_OK) {
        if (HAL_ADC_PollForConversion(&hadc2, 10) == HAL_OK) {
            temp_raw = HAL_ADC_GetValue(&hadc2);
            temp_v   = (float)temp_raw * 3.3f / 4095.0f;
        }
        HAL_ADC_Stop(&hadc2);
    }

    // FFT 계산 및 supersonic 메트릭
    ExtractFullFFT(fft_packet);
    float supersonic_val = compute_supersonic_rms_from_fftdata(
        fft_packet, FFT_SIZE/2
    );

    // 다음 프레임 준비 + 카운트 증가
    Ultra_ResumeNextFrame();
    g_monitor_count++;

    uint8_t  out[240];
        size_t   olen = 0;
        cbor_packet_t rp = (cbor_packet_t){0};

        rp.has_k     = 1; rp.k = 1;                // resp
        rp.has_ok    = 1; rp.ok = 1;
        rp.has_topic = 1; strcpy(rp.topic, "snap");// t: "snap"
        rp.has_temp = 1;
        rp.temp     = temp_v;
        // (선택) MID/UID/nonce 반사
        // rp.has_mid=1; rp.mid=my_mid;
        // if (cp->has_n){ rp.has_n=1; rp.n=cp->n; }

        // 전압/전류(부동소수)
        rp.has_volt = 1; rp.volt = vin_v;          // V
        rp.has_curr = 1; rp.curr = i_adc_v;        // A(또는 ADC-V)

        // FFT: (freq, amp) 쌍 up to 23개
        rp.has_fft  = 1;
        rp.fft_len  = 0;
        uint16_t nbins = FFT_SIZE/2;
        for (uint16_t b = 1; b < nbins && rp.fft_len < SNAP_FFT_PAIRS; ++b) {
            float freq = (float)b * (float)SAMPLING_RATE / (float)FFT_SIZE;
            rp.fft[rp.fft_len].freq = freq;
            rp.fft[rp.fft_len].amp  = fft_packet[b].amplitude;
            rp.fft_len++;
            // 간단히 앞쪽 몇 개를 싣는 방식. 원하면 피크 추출/등간 샘플링으로 바꿔도 됨.
        }

        if (cbor_encode_packet(out, sizeof(out), &rp, &olen) && olen <= 253) {
            send_wisun_resp(g_last_rx_tmid, out, olen);
        } else {
            // 너무 커졌거나 실패하면 축소해서 재시도(예: FFT 개수 더 줄이기)
            // 또는 간단 ACK만:
            cbor_packet_t ack = (cbor_packet_t){0};
            ack.has_k=1; ack.k=1; ack.has_ok=1; ack.ok=0; ack.has_topic=1; strcpy(ack.topic,"snap");
            if (cbor_encode_packet(out, sizeof(out), &ack, &olen)) {
                send_wisun_resp(g_last_rx_tmid, out, olen);
            }
        }
}

// Wi-SUN으로 한 번에 송신
static void send_cbor_now(const cbor_packet_t* rp)
{
    uint8_t out[256]; size_t n=0;
    if (!cbor_encode_packet(out, sizeof(out), rp, &n)) return;

    wisun_frame_cfg_t cfg = { .sig1=0xAA, .sig2=0xAA, .tmid=0x0000 };
    (void)wisun_send_frame(&cfg, out, n, wisun_tx_adapter, NULL);
}

static bool get_latest_snapshot(snapshot_t* out)
{
    if (!g_snap_inited) return false;
    uint8_t last = (g_snap_head + SNAP_RING_SIZE - 1) % SNAP_RING_SIZE;
    *out = g_snap[last];
    return true;
}

static void handle_req(const cbor_packet_t* cp)
{
    // 1) 타겟 판정: mid 없거나 0이거나 내 MID면 실행
    bool target = (!cp->has_mid) || (cp->mid == 0) || (cp->mid == my_mid);
    if (!target) return;

    // === light_on ===
    if (cp->has_topic && strcmp(cp->topic, "light_on") == 0) {
        if (cp->p_has_on) {
            HAL_GPIO_WritePin(LIGHT_GPIO_Port, LIGHT_Pin,
                              cp->p_on ? GPIO_PIN_SET : GPIO_PIN_RESET);

            // (옵션) 슬롯 지연 응답 파라미터 — 실제로 필드가 온다면만 사용
            /*
            resp_slot_cfg_t scfg = {
                .start_after_ms = (cp->p_has_start_after_ms ? cp->p_start_after_ms : 1000),
                .slot_len_ms    = (cp->p_has_slot_len_ms    ? cp->p_slot_len_ms    : 1500),
                .jitter_ms      = (cp->p_has_jitter_ms      ? cp->p_jitter_ms      : 200),
                .max_mid        = (cp->p_has_max_mid        ? cp->p_max_mid        : 30),
                .order          = ORDER_MID_DESC,
            };
            __disable_irq();
            g_resp.p_on_valid = 1;
            g_resp.p_on       = cp->p_on;
            __enable_irq();

            schedule_ordered_response(cp->has_n ? cp->n : 0, "light_on", 1, &scfg);
            */

            // 즉시 ACK 응답 (간단)
            uint8_t ob[128]; size_t on = 0;
            cbor_packet_t rp = (cbor_packet_t){0};
            rp.has_k = 1;  rp.k = 1;             // resp
            rp.has_ok = 1; rp.ok = 1;
            rp.has_topic = 1; strcpy(rp.topic, "light_on");
            if (cp->has_n) { rp.has_n = 1; rp.n = cp->n; }
            if (cbor_encode_packet(ob, sizeof(ob), &rp, &on)) {
                extern volatile uint16_t g_last_rx_tmid;
                (void)send_wisun_resp(g_last_rx_tmid, ob, on);
            }
        }
    }

    // === assign_mid ===
    else if (cp->has_topic && strcmp(cp->topic, "assign_mid") == 0) {
        uint8_t uid12[12]; mid_pack_uid12(uid12);

        if (cp->p_has_uid && memcmp(cp->p_uid, uid12, 12) == 0 && cp->p_has_new_mid) {
            uint16_t new_mid = cp->p_new_mid;
            if (new_mid != 0 && new_mid != MID_INVALID) {
                my_mid = new_mid;
                // save_mid_to_flash(my_mid); // ← 플래시 미사용이면 제거/주석
            }

            // ACK 응답
            uint8_t ob[128]; size_t on = 0;
            cbor_packet_t rp = (cbor_packet_t){0};
            rp.has_k = 1; rp.k = 1;
            rp.has_topic = 1; strcpy(rp.topic, "assign_mid");
            rp.has_mid = 1; rp.mid = my_mid;
            rp.has_uid = 1; memcpy(rp.uid, uid12, 12);
            if (cp->has_n) { rp.has_n = 1; rp.n = cp->n; }
            rp.has_ok = 1; rp.ok = 1;

            if (cbor_encode_packet(ob, sizeof(ob), &rp, &on)) {
                extern volatile uint16_t g_last_rx_tmid;
                (void)send_wisun_resp(g_last_rx_tmid, ob, on);
            }
        }
    }

    // === state_req ===
    else if (cp->has_topic && strcmp(cp->topic, "state_req") == 0) {
        uint8_t uid12[12]; mid_pack_uid12(uid12);

        cbor_packet_t rp = (cbor_packet_t){0};
        rp.has_k = 1; rp.k = 1;
        rp.has_topic = 1; strcpy(rp.topic, "state");
        rp.has_uid = 1; memcpy(rp.uid, uid12, 12);
        rp.has_mid = 1; rp.mid = my_mid;
        if (cp->has_n) { rp.has_n = 1; rp.n = cp->n; }
        rp.has_ok = 1; rp.ok = 1;
        // TODO: 필요 시 측정치/상태 추가

        uint8_t ob[128]; size_t on = 0;
        if (cbor_encode_packet(ob, sizeof(ob), &rp, &on)) {
            extern volatile uint16_t g_last_rx_tmid;
            (void)send_wisun_resp(g_last_rx_tmid, ob, on);
        }
    }
    else if (cp->has_topic && strcmp(cp->topic, "cmd") == 0) {
        bool target = (!cp->has_mid) || (cp->mid==0) || (cp->mid==my_mid);
        if (!target) return;

        int cmdv = -1;
        if (cp->has_raw)      cmdv = (int)cp->raw;  // 게이트웨이가 3→0x13 보낼 수 있음
        else if (cp->has_cmd) cmdv = (int)cp->cmd;

        if (cmdv == 0x13 || cmdv == 0x03) {
            // 1회 스냅샷: 기존 함수 그대로 사용
            Send_Monitoring_Snapshot_JSON();
            return;
        }
    }
     else if (cp->has_topic && strcmp(cp->topic, "snap_cfg") == 0) {
        // target 체크는 위랑 똑같이
        bool target = (!cp->has_mid) || (cp->mid==0) || (cp->mid==my_mid);
        if (!target) return;

        // 예: cp->p_has_on : 1 = enable, 0 = disable
        //     cp->p_has_period_ms : 주기 ms (CBOR 스키마에 맞게 필드명 조정)
        if (cp->p_has_on) {
            g_snap_enable = cp->p_on ? 1 : 0;
        }
        if (cp->p_has_period_ms) {
            g_snap_interval_ms = cp->p_period_ms;
            if (g_snap_interval_ms < 1000) g_snap_interval_ms = 1000; // 1초 밑은 막기
        }
        g_snap_next_tick = HAL_GetTick() + g_snap_interval_ms;

        // ACK 하나 보내고 끝내도 됨
        uint8_t ob[128]; size_t on=0;
        cbor_packet_t rp = {0};
        rp.has_k=1; rp.k=1;
        rp.has_topic=1; strcpy(rp.topic,"snap_cfg");
        rp.has_ok=1; rp.ok=1;
        if (cp->has_n) { rp.has_n=1; rp.n=cp->n; }

        if (cbor_encode_packet(ob,sizeof(ob),&rp,&on)) {
            send_wisun_resp(g_last_rx_tmid, ob, on);
        }
    }
    // else if (cp->has_topic && strcmp(cp->topic,"your_new_cmd")==0) { ... }
}


/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART1_UART_Init();
  MX_USART2_UART_Init();
  MX_ADC1_Init();
  MX_USART6_UART_Init();
  MX_TIM2_Init();
  MX_RTC_Init();
  Read_UID();
  init_uid_string();

  mid_storage_init();
  if (load_mid_from_flash(&loaded)) {
      my_mid = loaded;
  } else {
      my_mid = MID_INVALID; // 미할당 상태
  }
  /* USER CODE BEGIN 2 */
  HAL_UART_Receive_IT(&huart1, &rxByte1, 1);
  HAL_UART_Receive_IT(&huart6, &rxByte, 1);

  if (HAL_ADCEx_Calibration_Start(&hadc1, ADC_SINGLE_ENDED) != HAL_OK)
  {
    Error_Handler();
  }
  HAL_ADC_Start_IT(&hadc1);
  /*if (HAL_ADC_Start_DMA(&hadc1, (uint32_t *)adc_dma_buffer, FFT_SIZE) != HAL_OK)
    {
        Error_Handler();
    }*/
  SCB->SHCSR &= ~(SCB_SHCSR_MEMFAULTENA_Msk);
        __DSB();
        __ISB();

  //if (ICACHE->CR & ICACHE_CR_EN)  // ICACHE ???? ?  ?  ?  ?  ?   ?  ?   ???? ?  ?
	//  {
		  //ICACHE->CR &= ~ICACHE_CR_EN;  // ICACHE 비활?  ?
		  //__DSB();  // Data Synchronization Barrier
		  //__ISB();  // Instruction Synchronization Barrier
	  //}

        //Send_UID_UART2();
//        HAL_DAC_Start(&hdac1, DAC_CHANNEL_2);

    if (arm_rfft_fast_init_f32(&fftInstance, FFT_SIZE) != ARM_MATH_SUCCESS) {
        char msg[] = "❌ FFT 초기화 실패\r\n";
        HAL_UART_Transmit(&huart6, (uint8_t*)msg, sizeof(msg) - 1, HAL_MAX_DELAY);
    }
    HAL_TIM_Base_Start(&htim2);   // now_us()용 타이머 시작
    //Ultra_StartSampling();


  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
    while (1)
    {
        if (wisun_packet_ready) {
            __disable_irq();
            uint16_t len = wisun_packet_len;
            uint8_t  buf[PACKET_MAX_SIZE];
            memcpy(buf, wisun_packet_shadow, len);
            wisun_packet_ready = 0;
            __enable_irq();

            wisun_frame_view_t v = {0};
            if (wisun_parse_frame(buf, len, &v)) {
                // ★ 응답에서 반사용 TMID 저장
                g_last_rx_tmid = v.tmid;

                const uint8_t *cbor = NULL; size_t cbor_len = 0;
                if (find_cbor_map_slice(v.data, v.data_len, &cbor, &cbor_len)) {
                    cbor_packet_t cp = {0};
                    if (cbor_decode_packet(cbor, cbor_len, &cp)) {
                        uint8_t kind = cp.has_k ? cp.k : 0xFF;
                        if (kind == 0) handle_req(&cp); // req만 처리
                    }
                }
            }
        }

        // ★ 여기! RX가 없어도 예약된 TX가 있으면 보내도록 주기적으로 폴링
        tx_task_poll();

        if (g_snap_enable) {
            uint32_t now = HAL_GetTick();
            if ((int32_t)(now - g_snap_next_tick) >= 0) {
                Send_Monitoring_Snapshot_JSON();
                g_snap_next_tick = now + g_snap_interval_ms;
            }
        }
    }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE
                              |RCC_OSCILLATORTYPE_CSI;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.LSIState = RCC_LSI_ON;
  RCC_OscInitStruct.CSIState = RCC_CSI_ON;
  RCC_OscInitStruct.CSICalibrationValue = RCC_CSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLL1_SOURCE_CSI;
  RCC_OscInitStruct.PLL.PLLM = 1;
  RCC_OscInitStruct.PLL.PLLN = 125;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1_VCIRANGE_2;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1_VCORANGE_WIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_PCLK3;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure the programming delay
  */
  __HAL_FLASH_SET_PROGRAM_DELAY(FLASH_PROGRAMMING_DELAY_2);
}

/**
  * @brief ADC1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_ADC1_Init(void)
{

  /* USER CODE BEGIN ADC1_Init 0 */

  /* USER CODE END ADC1_Init 0 */

  ADC_ChannelConfTypeDef sConfig = {0};
  ADC_InjectionConfTypeDef sConfigInjected = {0};

  /* USER CODE BEGIN ADC1_Init 1 */

  /* USER CODE END ADC1_Init 1 */

  /** Common config
  */
  hadc1.Instance = ADC1;
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.ScanConvMode = ADC_SCAN_ENABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
  hadc1.Init.LowPowerAutoWait = DISABLE;
  hadc1.Init.ContinuousConvMode = ENABLE;
  hadc1.Init.NbrOfConversion = 1;
  hadc1.Init.DiscontinuousConvMode = DISABLE;
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
  hadc1.Init.DMAContinuousRequests = DISABLE;
  hadc1.Init.SamplingMode = ADC_SAMPLING_MODE_NORMAL;
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
  hadc1.Init.OversamplingMode = DISABLE;
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
  {
    Error_Handler();
  }

  /** Disable Injected Queue
  */
  HAL_ADCEx_DisableInjectedQueue(&hadc1);

  /** Configure Regular Channel
  */
  sConfig.Channel = ADC_CHANNEL_18;
  sConfig.Rank = ADC_REGULAR_RANK_1;
  sConfig.SamplingTime = ADC_SAMPLETIME_6CYCLES_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_3;
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_1;
  sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_24CYCLES_5;
  sConfigInjected.InjectedSingleDiff = ADC_SINGLE_ENDED;
  sConfigInjected.InjectedOffsetNumber = ADC_OFFSET_NONE;
  sConfigInjected.InjectedOffset = 0;
  sConfigInjected.InjectedNbrOfConversion = 2;
  sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
  sConfigInjected.AutoInjectedConv = DISABLE;
  sConfigInjected.QueueInjectedContext = DISABLE;
  sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
  sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONV_EDGE_NONE;
  sConfigInjected.InjecOversamplingMode = ENABLE;
  sConfigInjected.InjecOversampling.Ratio = ADC_OVERSAMPLING_RATIO_2;
  sConfigInjected.InjecOversampling.RightBitShift = ADC_RIGHTBITSHIFT_1;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
  {
    Error_Handler();
  }

  /** Configure Injected Channel
  */
  sConfigInjected.InjectedChannel = ADC_CHANNEL_5;
  sConfigInjected.InjectedRank = ADC_INJECTED_RANK_2;
  if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN ADC1_Init 2 */

  /* USER CODE END ADC1_Init 2 */

}

/**
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

  RTC_PrivilegeStateTypeDef privilegeState = {0};
  RTC_TimeTypeDef sTime = {0};
  RTC_DateTypeDef sDate = {0};

  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
  hrtc.Init.BinMode = RTC_BINARY_NONE;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
  {
    Error_Handler();
  }
  privilegeState.rtcPrivilegeFull = RTC_PRIVILEGE_FULL_NO;
  privilegeState.backupRegisterPrivZone = RTC_PRIVILEGE_BKUP_ZONE_NONE;
  privilegeState.backupRegisterStartZone2 = RTC_BKP_DR0;
  privilegeState.backupRegisterStartZone3 = RTC_BKP_DR0;
  if (HAL_RTCEx_PrivilegeModeSet(&hrtc, &privilegeState) != HAL_OK)
  {
    Error_Handler();
  }

  /* USER CODE BEGIN Check_RTC_BKUP */

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  sTime.Hours = 0x0;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;
  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }

  /** Enable the TimeStamp
  */
  if (HAL_RTCEx_SetTimeStamp(&hrtc, RTC_TIMESTAMPEDGE_RISING, RTC_TIMESTAMPPIN_DEFAULT) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}

/**
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
  TIM_MasterConfigTypeDef sMasterConfig = {0};

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
  htim2.Init.Prescaler = 0;
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
  htim2.Init.Period = 276;
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
  {
    Error_Handler();
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
  {
    Error_Handler();
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}

/**
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{

  /* USER CODE BEGIN USART1_Init 0 */

  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
  huart1.Init.BaudRate = 9600;
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 9600;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 115200;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  huart6.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
  huart6.Init.ClockPrescaler = UART_PRESCALER_DIV1;
  huart6.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart6, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart6, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
  {
    Error_Handler();
  }
  if (HAL_UARTEx_DisableFifoMode(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */
  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, GPIO_PIN_RESET);

  /*Configure GPIO pin : PA12 */
  GPIO_InitStruct.Pin = GPIO_PIN_12;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */
    GPIO_InitStruct.Pin = GPIO_PIN_4;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	GPIO_InitStruct.Pin = GPIO_PIN_6;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	GPIO_InitStruct.Pin = GPIO_PIN_1;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);


  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/*void Process_WiSun_Command(uint8_t *data, uint8_t len) {
    uint8_t cmd_id = data[IDX_CMD_ID];
    switch (cmd_id) {


    	case CMD_READ_UID: {
                char uid_str[32];
                Format_UID(uid_str, sizeof(uid_str));
                // uid_str 예: "00112233-44556677-8899AABB\r\n"

                // 패킷 헤더(STX/SIG/LEN/TMID) + uid_str + CS + ETX 구성
                uint8_t resp[64];
                int idx = 0;
                resp[idx++] = PACKET_STX;
                resp[idx++] = SIG1;
                resp[idx++] = SIG2;
                // LEN = TMID(1) + uid_str 길이 + CS(1) + ETX(1)
                resp[idx++] = 1 + strlen(uid_str) + 1 + 1;
                resp[idx++] = CMD_READ_UID;
                // 페이로드로 uid_str 복사
                memcpy(&resp[idx], uid_str, strlen(uid_str));
                idx += strlen(uid_str);
                // 체크섬
                resp[idx++] = calc_checksum(&resp[1], idx-1);
                resp[idx++] = PACKET_ETX;

                HAL_UART_Transmit(&huart1, resp, idx, HAL_MAX_DELAY);
                break;
         }

        default:
            Send_NAK_UART1();
            break;
    }
}*/
/* static void Poll_Temperature_And_Print(void)
{
    static uint32_t last_temp_tick = 0;
    uint32_t now = HAL_GetTick();

    // 500ms마다 한 번만 측정
    if ((int32_t)(now - last_temp_tick) < 0) return;
    if (now - last_temp_tick < 500) return;
    last_temp_tick = now;

    if (HAL_ADC_Start(&hadc2) != HAL_OK) return;

    if (HAL_ADC_PollForConversion(&hadc2, 10) == HAL_OK) {
        uint16_t raw = HAL_ADC_GetValue(&hadc2);
        float v = (raw * 3.3f) / 4095.0f;

        char msg[64];
        int n = snprintf(msg, sizeof(msg),
                         "TEMP ADC2 raw=%u, V=%.3f\r\n", raw, v);
        HAL_UART_Transmit(&huart6, (uint8_t*)msg, n, 100);
    }
    HAL_ADC_Stop(&hadc2);
} */

void Vac_Ctrl(void) {
	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_12, 1);

}

static void Read_UID_local(void){
    Read_UID(); // 기존 함수로 UID를 uid_ram[]에 읽음
    uid_ram_local[0] = uid_ram[0];
    uid_ram_local[1] = uid_ram[1];
    uid_ram_local[2] = uid_ram[2];
}
static void init_uid_string(void){
    Read_UID_local();
    snprintf(g_uid_str, sizeof(g_uid_str),
             "%08" PRIX32 "-%08" PRIX32 "-%08" PRIX32,
             uid_ram_local[2], uid_ram_local[1], uid_ram_local[0]);
}

void Read_UID(void) {
    uid_ram[0] = UID_ADDRESS[0];
    uid_ram[1] = UID_ADDRESS[1];
    uid_ram[2] = UID_ADDRESS[2];
}


void Format_UID(char *msg, size_t size) {
    Read_UID();  // Unique ID ?   ??
    snprintf(msg, size, "%08" PRIX32 "-%08" PRIX32 "-%08" PRIX32 "\r\n",
             uid_ram[2], uid_ram[1], uid_ram[0]);
}

// ?   UART2 ?? Unique ID ?  ?  ?  ?   ?  ?
/*void Send_UID_UART2(void) {
    char msg[100];  // 메시 ??????????? 버퍼
    Format_UID(msg, sizeof(msg));  // Unique ID ??????????? 문자?   ???????????  ????????????
    HAL_UART_Transmit(&huart6, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
}*/
uint32_t Get_Device_ID(void) {
           return DBGMCU->IDCODE;  // Device ID ?   ??
}

uint32_t Read_ADC_Channel(uint32_t channel) {
    ADC_ChannelConfTypeDef sConfig = {0};

    sConfig.Channel = channel;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_247CYCLES_5;
    sConfig.SingleDiff = ADC_SINGLE_ENDED;
    sConfig.OffsetNumber = ADC_OFFSET_NONE;
    sConfig.Offset = 0;

    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
        Error_Handler();
    }

    HAL_ADC_Start(&hadc1);
    if (HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY) != HAL_OK) {
        Error_Handler();
    }

    uint32_t value = HAL_ADC_GetValue(&hadc1);
    HAL_ADC_Stop(&hadc1);
    return value;
}

float Convert_Voltage_ADC(uint32_t adc_value) {
    float vref_actual = 3.3;
    float voltage = ((float)adc_value / 4095.0f) * vref_actual;
    return voltage;
}

float Convert_Voltage_To_Current(float voltage, float offset) {
    float current = (voltage - offset) / 0.137f;
    return current;
}


void Print_Voltage_Current(void) {
	ADC_ChannelConfTypeDef sConfig = {0};
	    uint32_t adc_val_current;
	    char log[64];

	    // === 전류 입력 채널 설정: PA6 (ADC_CHANNEL_3) ===
	    sConfig.Channel = ADC_CHANNEL_3;  // PA6
	    sConfig.Rank = ADC_REGULAR_RANK_1;
	    sConfig.SamplingTime = ADC_SAMPLETIME_247CYCLES_5;
	    sConfig.SingleDiff = ADC_SINGLE_ENDED;
	    sConfig.OffsetNumber = ADC_OFFSET_NONE;
	    sConfig.Offset = 0;

	    if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) {
	        Error_Handler();
	    }

	    HAL_ADC_Start(&hadc1);
	    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
	    adc_val_current = HAL_ADC_GetValue(&hadc1);
	    HAL_ADC_Stop(&hadc1);

	    // === 변환: ADC → 전압 → 전류 변환 (옵션) ===
	    float voltage = Convert_Voltage_ADC(adc_val_current);  // 예: 3.3 * adc / 4095
	    float current = Convert_Voltage_To_Current(voltage, 2.50f);  // 기준 전압은 상황에 따라 조정

	    // === 출력 ===
	    snprintf(log, sizeof(log),
	             "ADC_RAW_CURR: %lu | Voltage: %.2fV | Current: %.2fA\r\n",
	             adc_val_current, voltage, current);

	    HAL_UART_Transmit(&huart6, (uint8_t*)log, strlen(log), HAL_MAX_DELAY);
}

void PrintReceivedPacket(const char* prefix, const uint8_t* data, uint16_t length) {
    char msg[256];
    uint32_t timestamp = HAL_GetTick();
    RTC_TimeTypeDef sTime;
    RTC_DateTypeDef sDate;

    HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
    HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);

    int pos = 0;
    pos += snprintf(msg, sizeof(msg), "[%02d:%02d:%02d] %s",
                        sTime.Hours, sTime.Minutes, sTime.Seconds, prefix);
    for (int i = 0; i < length && pos < sizeof(msg) - 3; i++) {
        pos += snprintf(&msg[pos], sizeof(msg) - pos, "%02X ", data[i]);
    }

    msg[pos++] = '\r';
    msg[pos++] = '\n';
    msg[pos] = '\0';

    HAL_UART_Transmit(&huart6, (uint8_t*)msg, pos, HAL_MAX_DELAY);
}


uint8_t calc_checksum(uint8_t *buf, uint16_t len) {
	uint8_t sum = 0;
	for (uint16_t i = 0; i < len; i++) sum += buf[i];
	return sum;
}

void startADCInterrupt(void) {
    adc_index = 0;
    adc_done = 0;
    HAL_ADC_Start_IT(&hadc1);
}

void ExtractFullFFT(FftData_t *dest) {
    // DC Offset 제거
    float32_t mean = 0.0f;
    int max_bin = FFT_SIZE / 2;
    for (int i = 0; i < FFT_SIZE; i++) mean += inputSignal[i];
    mean /= FFT_SIZE;
    for (int i = 0; i < FFT_SIZE; i++) inputSignal[i] -= mean;

    // FFT 수행
    processFFT(inputSignal, outputSignal, magnitude);

    // 결과 저장
    /*for (int i = 0; i < FFT_SIZE / 2; i++) {  // ✅ 중요: FFT_SIZE / 2 만큼만 저장해야 함
        dest[i].freq = (uint16_t)((i * SAMPLING_RATE) / FFT_SIZE);
        dest[i].amplitude = magnitude[i];
    }*/
    for (int i = 0; i < FFT_SIZE / 2; i++) {
            float freq = (float)(i * SAMPLING_RATE) / FFT_SIZE;
            if (freq > SAMPLING_RATE / 2.0f) break;

            dest[i].freq = freq;
            dest[i].amplitude = magnitude[i]; /*/ (FFT_SIZE / 2);*/  // ✅ 여기서 보정 적용
        }
}


void Query_MID_From_WiSUN() {
    const char *cmd = "AT+MID?\r\n";
    HAL_UART_Transmit(&huart1, (uint8_t*)cmd, strlen(cmd), HAL_MAX_DELAY);

}

void Parse_AT_Response(const char* buffer) {
    // "AT+MID=" 문자열이 포함되어 있는지 확인
    const char* mid_ptr = strstr(buffer, "AT+MID=");
    if (mid_ptr) {
        int mid = atoi(mid_ptr + 7);  // "AT+MID=" 다음 숫자 추출
        if (mid >= 0 && mid <= 65535) {
            my_mid = (uint16_t)mid;
            // 디버깅 출력
            char msg[50];
            snprintf(msg, sizeof(msg), "Parsed MID: %d\r\n", my_mid);
            HAL_UART_Transmit(&huart6, (uint8_t*)msg, strlen(msg), HAL_MAX_DELAY);
        }
    }
}

void Ultra_StartSampling(void) {
    wr_idx = 0;
    ultra_frame_ready = false;
    ultra_sampling_paused = false;
    HAL_ADC_Start_IT(&hadc1);   // IN18 연속변환 시작(Continuous=Enable 가정)
}

void Ultra_ResumeNextFrame(void) {
    wr_idx = 0;
    ultra_frame_ready = false;
    ultra_sampling_paused = false;
    HAL_ADC_Start_IT(&hadc1);
}

//============================================= 변화 기반 ====================================//
/*void loop_fft_for_duration(uint32_t duration_ms) {
    uint32_t start_time = HAL_GetTick();
    char msg[64];
    uint16_t prev_raw = 0;
    const uint16_t THRESHOLD_DIFF = 30;  // 진폭 튐 감지 기준

    while (HAL_GetTick() - start_time < duration_ms) {
        bool should_perform_fft = false;

        for (int i = 0; i < FFT_SIZE; i++) {
            HAL_ADC_Start(&hadc1);

            uint16_t raw = 0;
            for (int rank = 0; rank < 3; rank++) {
                HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);
                uint16_t value = HAL_ADC_GetValue(&hadc1);
                if (rank == 2) {
                    raw = value;
                }
            }
            HAL_ADC_Stop(&hadc1);

            // === raw 값 UART6 출력 ===
            int raw_len = snprintf(msg, sizeof(msg), "RAW[%d]: %u\r\n", i, raw);
            HAL_UART_Transmit(&huart6, (uint8_t*)msg, raw_len, HAL_MAX_DELAY);

            if (i > 0 && abs((int)raw - (int)prev_raw) > THRESHOLD_DIFF) {
                should_perform_fft = true;
            }
            prev_raw = raw;

            inputSignal[i] = ((float32_t)raw) * (3.3f / 4095.0f) - 1.65f;
        }

        if (should_perform_fft) {
            ExtractFullFFT(fft_packet);
            for (int i = 0; i < FFT_SIZE / 2; i += 16) {
                int len = snprintf(msg, sizeof(msg), "%u,%.4f\r\n",
                                   fft_packet[i].freq, fft_packet[i].amplitude);
                HAL_UART_Transmit(&huart6, (uint8_t*)msg, len, HAL_MAX_DELAY);
            }
        } else {
            char skip_msg[] = "No significant signal change, FFT skipped\r\n";
            HAL_UART_Transmit(&huart6, (uint8_t*)skip_msg, strlen(skip_msg), HAL_MAX_DELAY);
        }

        HAL_Delay(FFT_DELAY_MS);
    }

    char done[] = "=== 1분 FFT 측정 완료 ===\r\n";
    HAL_UART_Transmit(&huart6, (uint8_t*)done, strlen(done), HAL_MAX_DELAY);
}*/

/*void Transfer_ADC_To_DAC(void)
{

    HAL_ADC_Start(&hadc1);


    HAL_ADC_PollForConversion(&hadc1, HAL_MAX_DELAY);


    uint32_t adc_val = HAL_ADC_GetValue(&hadc1);


    HAL_DAC_SetValue(&hdac1, DAC_CHANNEL_2, DAC_ALIGN_12B_R, adc_val);
}*/

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
	  HAL_UART_Transmit(&huart6, (uint8_t *)"Error_Handler called\r\n", 23, HAL_MAX_DELAY);
	  HAL_Delay(500);
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
